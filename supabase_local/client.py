# supabase/client.py (VERS√ÉO COM INTEGER)

import streamlit as st
from supabase import create_client, Client
import pandas as pd
import logging

logger = logging.getLogger(__name__)

class SupabaseClient:
    """Cliente Supabase com isolamento autom√°tico de dados por user_id (multi-tenant)."""
    
    def __init__(self):
        self.client: Client = self._initialize_client()
        # Obt√©m o user_id do usu√°rio logado (INTEGER)
        self.user_id = self._get_current_user_id()

    def _initialize_client(self) -> Client:
        """Inicializa a conex√£o com o Supabase."""
        try:
            # Verifica se as credenciais existem
            if "supabase" not in st.secrets:
                error_msg = """
                ‚ùå **Configura√ß√£o do Supabase n√£o encontrada!**
                
                Para usar este aplicativo, voc√™ precisa configurar as credenciais do Supabase no Streamlit Cloud:
                
                1. Acesse as configura√ß√µes do seu app no Streamlit Cloud
                2. V√° em "Settings" > "Secrets"
                3. Adicione as seguintes configura√ß√µes:
                
                ```toml
                [supabase]
                url = "https://seu-projeto.supabase.co"
                key = "sua-anon-key"
                ```
                
                **Para obter essas credenciais:**
                - Acesse seu projeto no Supabase
                - V√° em Settings > API
                - Copie a URL do projeto e a anon key
                """
                st.error(error_msg)
                st.stop()
                raise ValueError("Configura√ß√£o do Supabase ausente")
            
            url = st.secrets["supabase"].get("url")
            key = st.secrets["supabase"].get("key")
            
            if not url or not key:
                error_msg = """
                ‚ùå **Credenciais do Supabase incompletas!**
                
                Verifique se voc√™ configurou corretamente no Streamlit Cloud:
                
                ```toml
                [supabase]
                url = "https://seu-projeto.supabase.co"
                key = "sua-anon-key"
                ```
                """
                st.error(error_msg)
                st.stop()
                raise ValueError("Credenciais do Supabase incompletas")
            
            # Valida formato da URL
            if not url.startswith("https://"):
                st.error("‚ùå URL do Supabase deve come√ßar com https://")
                st.stop()
                raise ValueError("URL do Supabase inv√°lida")
            
            # Cria cliente com timeout
            import requests
            import time
            
            start_time = time.time()
            client = create_client(url, key)
            
            # Testa conex√£o b√°sica
            try:
                # Teste simples de conectividade
                test_response = client.table("usuarios").select("id").limit(1).execute()
                logger.info("‚úÖ Conex√£o com Supabase testada com sucesso")
            except Exception as test_error:
                logger.warning(f"‚ö†Ô∏è Aviso: Teste de conex√£o falhou: {test_error}")
                # N√£o falha aqui, apenas avisa
            
            elapsed_time = time.time() - start_time
            logger.info(f"‚úÖ Cliente Supabase inicializado em {elapsed_time:.2f}s")
            return client
            
        except KeyError as e:
            error_msg = f"Configura√ß√£o do Supabase ausente: {e}"
            logger.error(error_msg)
            st.error(error_msg)
            st.stop()
            raise
        except Exception as e:
            error_msg = f"Erro ao inicializar cliente Supabase: {e}"
            logger.error(error_msg)
            st.error(error_msg)
            st.stop()
            raise

    def _get_current_user_id(self) -> int:
        """Obt√©m o user_id (INTEGER) do usu√°rio logado da sess√£o."""
        try:
            # Evita depend√™ncia circular - obt√©m user_id diretamente da sess√£o
            user_id = st.session_state.get('current_user_id')
            if user_id:
                try:
                    return int(user_id)
                except (ValueError, TypeError):
                    logger.warning(f"user_id na sess√£o n√£o √© um n√∫mero v√°lido: {user_id}")
            
            # Fallback: tenta obter via consulta direta ao Supabase
            # para evitar depend√™ncia circular com auth_utils
            try:
                user_email = st.session_state.get('user_email')
                if user_email:
                    # Consulta direta ao Supabase para obter user_id
                    response = self.client.table("usuarios").select("id").eq("email", user_email).execute()
                    if response.data:
                        raw_id = response.data[0]['id']
                        try:
                            return int(raw_id)
                        except (ValueError, TypeError):
                            logger.warning(f"ID do Supabase n√£o √© um n√∫mero v√°lido: {raw_id}")
                            return None
            except Exception as fallback_error:
                logger.warning(f"Fallback para obter user_id falhou: {fallback_error}")
            
            return None
        except Exception as e:
            logger.warning(f"N√£o foi poss√≠vel obter user_id: {e}")
            return None

    def get_data(self, table_name: str, filters: dict = None) -> pd.DataFrame:
        """
        Busca dados de uma tabela com ISOLAMENTO AUTOM√ÅTICO por user_id.
        
        Args:
            table_name: Nome da tabela no Supabase
            filters: Filtros adicionais opcionais (dict)
            
        Returns:
            DataFrame com os dados filtrados
        """
        try:
            # Tabelas GLOBAIS que N√ÉO devem ser filtradas por usu√°rio
            GLOBAL_TABLES = {
                "usuarios", 
                "log_auditoria", 
                "solicitacoes_acesso", 
                "notificacoes_pendentes", 
                "solicitacoes_suporte"
            }
            
            query = self.client.table(table_name).select("*")
            
            # üîí APLICA FILTRO DE SEGURAN√áA (multi-tenant) usando user_id
            if table_name not in GLOBAL_TABLES:
                if not self.user_id:
                    logger.warning(f"Usu√°rio n√£o identificado. N√£o √© poss√≠vel acessar '{table_name}'.")
                    st.warning(f"‚ö†Ô∏è Usu√°rio n√£o identificado para acessar '{table_name}'.")
                    return pd.DataFrame()
                
                query = query.eq('user_id', self.user_id)
                logger.info(f"üîí Filtro de seguran√ßa aplicado: user_id={self.user_id}")
            
            # Aplica filtros adicionais se fornecidos
            if filters:
                for key, value in filters.items():
                    query = query.eq(key, value)
            
            response = query.execute()
            
            if response.data:
                logger.info(f"‚úÖ {len(response.data)} registros lidos de '{table_name}'")
                return pd.DataFrame(response.data)
            
            logger.info(f"‚ÑπÔ∏è Nenhum registro encontrado em '{table_name}'")
            return pd.DataFrame()
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao ler '{table_name}': {e}")
            st.error(f"Erro ao carregar dados de '{table_name}': {e}")
            return pd.DataFrame()

    def append_data(self, table_name: str, data: dict or list[dict]):
        """
        Adiciona registros com INJE√á√ÉO AUTOM√ÅTICA do user_id.
        
        Args:
            table_name: Nome da tabela
            data: Dicion√°rio ou lista de dicion√°rios para inserir
            
        Returns:
            Resposta do Supabase
        """
        if not data:
            logger.warning("Tentativa de inserir dados vazios.")
            return None
        
        try:
            GLOBAL_TABLES = {
                "usuarios", 
                "log_auditoria", 
                "solicitacoes_acesso", 
                "notificacoes_pendentes", 
                "solicitacoes_suporte"
            }
            
            # üîí INJETA user_id automaticamente
            if table_name not in GLOBAL_TABLES:
                if not self.user_id:
                    raise ValueError("‚ùå Usu√°rio n√£o identificado. Imposs√≠vel salvar dados.")
                
                if isinstance(data, list):
                    for record in data:
                        record['user_id'] = self.user_id
                else:
                    data['user_id'] = self.user_id
                
                logger.info(f"üîí user_id {self.user_id} injetado nos registros")
            
            response = self.client.table(table_name).insert(data).execute()
            
            count = len(data) if isinstance(data, list) else 1
            logger.info(f"‚úÖ {count} registro(s) inserido(s) em '{table_name}'")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inserir em '{table_name}': {e}")
            st.error(f"Erro ao salvar dados em '{table_name}': {e}")
            raise

    def update_data(self, table_name: str, data: dict, filter_column: str, filter_value):
        """Atualiza registros na tabela com seguran√ßa multi-tenant."""
        try:
            GLOBAL_TABLES = {
                "usuarios", "log_auditoria", "solicitacoes_acesso", 
                "notificacoes_pendentes", "solicitacoes_suporte"
            }
            
            query = self.client.table(table_name).update(data)
            
            if table_name not in GLOBAL_TABLES:
                if not self.user_id:
                    raise ValueError("‚ùå Usu√°rio n√£o identificado.")
                query = query.eq('user_id', self.user_id)
            
            response = query.eq(filter_column, filter_value).execute()
            logger.info(f"‚úÖ Registro atualizado em '{table_name}'")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar '{table_name}': {e}")
            st.error(f"Erro ao atualizar dados em '{table_name}': {e}")
            raise

    def delete_data(self, table_name: str, filter_column: str, filter_value):
        """Remove registros da tabela com seguran√ßa multi-tenant."""
        try:
            GLOBAL_TABLES = {
                "usuarios", "log_auditoria", "solicitacoes_acesso", 
                "notificacoes_pendentes", "solicitacoes_suporte"
            }
            
            query = self.client.table(table_name).delete()
            
            if table_name not in GLOBAL_TABLES:
                if not self.user_id:
                    raise ValueError("‚ùå Usu√°rio n√£o identificado.")
                query = query.eq('user_id', self.user_id)
            
            response = query.eq(filter_column, filter_value).execute()
            logger.info(f"‚úÖ Registro deletado de '{table_name}'")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao deletar de '{table_name}': {e}")
            st.error(f"Erro ao deletar dados de '{table_name}': {e}")
            raise


@st.cache_resource
def get_supabase_client() -> SupabaseClient:
    """Retorna inst√¢ncia √∫nica (singleton) do cliente Supabase."""
    try:
        logger.info("üîÑ Inicializando cliente Supabase...")
        client = SupabaseClient()
        logger.info("‚úÖ Cliente Supabase criado com sucesso")
        return client
    except Exception as e:
        logger.error(f"‚ùå Falha cr√≠tica ao criar cliente Supabase: {e}")
        # N√£o retorna None para evitar erros em cascata
        # O erro j√° foi tratado no _initialize_client com st.stop()
        raise


def get_supabase_client_no_cache() -> SupabaseClient:
    """Vers√£o sem cache para casos de emerg√™ncia."""
    try:
        logger.info("üîÑ Inicializando cliente Supabase (sem cache)...")
        client = SupabaseClient()
        logger.info("‚úÖ Cliente Supabase criado com sucesso (sem cache)")
        return client
    except Exception as e:
        logger.error(f"‚ùå Falha cr√≠tica ao criar cliente Supabase (sem cache): {e}")
        st.error(f"Erro cr√≠tico de conex√£o: {e}")
        return None
